\section{Algorithmic Backends}\label{sec:al} % 8p
This section presents a mechanism for automatically generating
algorithmic backends from the formal semantics.
We define \emph{\dl}, a declarative language that defines the formal
semantics of Wasm (Sec.~\ref{sec:dl}),
\emph{\al}, an algorithmic language that defines the Wasm semantics
in a pseudocode style (Sec.~\ref{sec:aldef}),
and a \dl to \al transformation (Sec.~\ref{sec:dl2al}).
We then show how to generate a prose specification from the semantics
described in \al (Sec.~\ref{sec:prose}) and
support its interpretation (Sec.~\ref{sec:interp}).

\subsection{\dl: Declarative Language}\label{sec:dl} %0.5p
The DSL describes the formal semantics of Wasm, and
we abstract it into a \dl that only shows the features relevant to translation to an algorithmic representation.
Fig.~\ref{fig:dl-syntax} presents the syntax of \dl.

\begin{figure}[t]
\[
\small
\begin{array}{l@{~}c@{~}r@{~}l}
\text{Semantics} & \delta^*\\
\text{Definition} & \delta &::=& \rho\ \mid\ \lambda\\
\text{Reduction rule} & \rho &::=& \gamma \leadsto \gamma\ \mbox{---}\ \pi^*\\
\text{Configuration} & \gamma &::=&(\eta_\bot,\ \eta^*)\\
\text{Premise} & \pi &::=& \beta\ \mid\ \mathsf{\small otherwise}\\
\text{Helper function} &
\lambda &::=& \varx \kwrl \eta^* \kwrr\ \kwequ\ \eta\ \mbox{---}\ \pi^*\\
\text{Expression} & \eta &::=& \upsilon\ \mid\ \kappa\ \eta^*\ \mid \cdots \\
\text{Condition} & \beta  &::=& \eta\ = \eta\ \mid \cdots\\
\text{Value} & \upsilon &::=& \ssf{I32}\ \mid\ \ssf{I64}\ \mid\ 
\ssf{F32}\ \mid\ \ssf{F64}\ \mid\ 
\ssf{0}\ \mid\ \ssf{1}\ \mid\ t\ \mid\ \epsilon\ \mid \cdots \\
\text{Constructor} & \kappa &::=& \ssf{REF.IS\_NULL}\ \mid\ \ssf{REF.NULL}\
\mid\ \ssf{REF} \mid\ \ssf{NULL}\ \mid\ \ssf{CONST}\ \mid \cdots
\end{array}
\]
\caption{Syntax of \dl for Wasm}\label{fig:dl-syntax}
\end{figure}

The Wasm semantics is defined by a sequence of definitions $\delta^*$.
A definition is either a reduction rule $\rho$ or an auxiliary helper function $\lambda$.
A reduction rule $\gamma_1 \leadsto \gamma_2\ \mbox{---}\ \pi^*$ denotes that
when the current configuration of a program matches $\gamma_1$ and
all $\pi^*$ are evaluated to true, then the program configuration becomes $\gamma_2$.
A configuration $(\eta_\bot,\ \eta^*)$ denotes an optional Wasm program state $\eta_\bot$,
which is a pair of the current store and the current frame,
and a sequence of Wasm instructions $\eta^*$ that represents the current stack.
Because the details of the Wasm program states and instructions are
not relevant to this report,
we abstract them as $\eta$. We show only some cases used for concrete
examples in this report.
A premise $\pi$ is a condition $\beta$ or a special keyword
\ensuremath{\mathsf{\small otherwise}},
which denotes the negation of all the previous premises.
We also abstract the details of the Wasm conditions as $\beta$.
A helper function $\varx \kwrl \eta^* \kwrr\ \kwequ\ \eta\ \mbox{---}\ \pi^*$ denotes that
when a function named $\varx$ is called, its arguments are bound to parameters $\eta^*$
and a body expression $\eta$ is evaluated if all $\pi^*$ are evaluated to true.

For example, the semantics of \inblue{\ensuremath{\mathsf{ref.is\_null}}}
in Fig.~\ref{fig:dsl} corresponds to the following in \dl:
\[
\footnotesize
\begin{array}{l@{}l@{~}c@{~}l}
[&(\bot, [\upsilon, \ssf{REF.IS\_NULL}]) &\leadsto& (\bot, [\ssf{CONST\ I32\ 1}])
\mbox{---} [\upsilon = \ssf{REF.NULL}\ t],\\
&(\bot, [\upsilon, \ssf{REF.IS\_NULL}])&\leadsto&(\bot, [\ssf{CONST\ I32\ 0}])
\mbox{---}[\ssf{\small otherwise}] ]
\end{array}
\]
where a sequence is represented as comma separated elements
enclosed by $[$ and $]$.

\subsection{\al: Algorithmic Language}\label{sec:aldef} %1.5p
Before generating algorithmic backends, definitions in \dl are translated into definitions in \al,
an algorithmic language that defines the Wasm language semantics in a pseudocode style.

\begin{figure}[t]
\[
\small
\begin{array}{l@{~}r@{~}c@{~}c@{~}r@{~}lll}
\text{Program} & \progset &\ni& \prog &::=& \alg^*\\
\text{Algorithm} & \algset &\ni& \alg &::=&
\kwalg \; \varx \kwrl \expr^* \kwrr \; \kwcl \inst^* \kwcr \\
\text{Instruction} & \instset &\ni& \inst &::=&
    \kwif \; \cond \; \inst^* \; \inst^* & \mbox{If $\cond$, then: $\inst_1^*$ Else: $\inst_2^*$}\\
&&&& \mid&
    \kweither \; \inst^* \; \inst^* & \mbox{Either: $\inst_1^*$ Or: $\inst_2^*$}\\
&&&& \mid&
    \kwenter \; \expr \; \expr \; \inst^* & \mbox{Enter $\expr_1$ with label $\expr_2$\ :\ $\inst^*$}\\
&&&& \mid&
    \kwassert \; \cond  & \mbox{Assert: Due to validation, $\cond$.}\\
&&&& \mid&
    \kwpush \; \expr  & \mbox{Push $\expr$ to the stack.}\\
&&&& \mid&
    \kwpop \; \expr  & \mbox{Pop $\expr$ from the stack.}\\
&&&& \mid&
    \kwpopall \; \expr  & \mbox{Pop all values $\expr$ from the stack.}\\
&&&& \mid&
    \kwlet \; \expr \; \expr & \mbox{Let $\expr_1$ be $\expr_2$.}\\
&&&& \mid&
    \kwtrap & \mbox{Trap.}\\
&&&& \mid&
    \kwnop & \mbox{Do nothing.}\\
&&&& \mid&
    \kwreturn \; \expr^? & \mbox{Return $\expr^?$.}\\
&&&& \mid&
    \kwexecute \; \expr & \mbox{Execute $\expr$.}\\
&&&& \mid&
    \kwexecuteseq \; \expr & \mbox{Execute the sequence $\expr$.}\\
&&&& \mid&
    \kwperform \; \varx \; \expr^* & \mbox{Perform $\varx(\expr^*)$.}\\
&&&& \mid&
    \kwexit & \mbox{Exit current context.}\\
&&&& \mid&
    \kwreplace \; \expr \; \qual \; \expr & \mbox{Replace $\expr_1[\qual]$ with $\expr_2$.}
\\

\text{Expression} & \exprset &\ni& \expr &::=&
    \varx & \varx\\
&&&& \mid&
    \num & \num\\
&&&& \mid&
    \bcode{-} \; \expr & \bcode{-} \; \expr\\
&&&& \mid&
    \expr \; \binop \; \expr & \expr \; \binop \; \expr\\
&&&& \mid&
    \expr \kwsl \qual \kwsr & \expr \kwsl \qual \kwsr\\
&&&& \mid&
    \expr \kwsl \qual \kwsr \; \kwass \; \expr & \mbox{$\expr_1$ with $\qual$ replaced by $\expr_2$}\\
&&&& \mid&
    \expr \kwsl \qual \kwsr \; \kwext \; \expr & \mbox{$\expr_1$ with $\qual$ prepended/appended by $\expr_2$}\\
&&&& \mid&
    \kwcl (\varx \mapsto \expr)^* \kwcr & \{\ (\varx~\expr)^*\ \}\\
&&&& \mid&
    \expr \; \kwcat \; \expr & \expr_1~\expr_2\\
&&&& \mid&
    | \expr | & |\expr|\\
&&&&&& \mbox{the length of $\expr$}\\
&&&&\mid&
    \cnstr \kwrl \expr^* \kwrr & \cnstr(\expr^*)\\
&&&& \mid&
    \varx \kwrl \expr^* \kwrr & \varx~\expr^*\\
&&&& \mid&
    \wasmc \\

\text{Condition} & \condset &\ni& \cond &::=&
\multicolumn{2}{l}{
    \kwnot \; \cond \mid
    \cond \; \binop \; \cond \mid
    \expr \; \binop \; \expr \mid
    \kwiscaseof \; \expr \; \varx \mid
    \kwisdefined \; \expr \mid
    \kwisvalid \; \expr \mid
    \wasmc
}
\\

\text{Path} & \qualset &\ni& \qual &::=&
\multicolumn{2}{l}{
    \expr \mid
    \expr \bcode{:} \expr \mid
    \bcode{.} x
}
\\
%\text{Wasm} & \wasmcset &\ni& \wasmc \\
  % Wasm-specific condition
  % (* Conditions used in assertions *)
  % | TopLabelC                        (* "a label is now on the top of the stack" *)
  % | TopFrameC                       (* "a frame is now on the top of the stack" *)
  % | TopValueC of expr option (* "a value (of type expr)? is now on the top of the stack" *)
  % | TopValuesC of expr           (* "at least expr number of values on the top of the stack" *)
  \end{array}
\]
\vspace*{-1em}
\caption{Syntax of \al and its prose notation}\label{fig:al-syntax}
\end{figure}

Fig.~\ref{fig:al-syntax} presents the core syntax of \al.
The metavariables $\varx$ ranges over variables,
$\num$ ranges over numbers, and
$\cnstr$ ranges over constructors.
An \al program $\prog$ is a sequence of algorithms $\alg^*$,
which denotes the Wasm semantics.
An algorithm $\alg$ consists of a name $\varx$, parameters $\expr^*$,
and body instructions $\inst^*$, which denotes the semantics of a
language feature or a helper function used to describe the language semantics.
An instruction $\inst$ denotes a prose statement in the Wasm specification.
The figure also shows prose rendering of instructions and expressions.
The Wasm specification often uses specific phrases like ``the current frame'' and 
``a label is now on the top of the stack.''
We abstract such Wasm-specific expressions and conditions as $\wasmc$ for brevity.
Note that an \al expression may have a different prose rendering
depending on where it appears. For example, $|e|$ is rendered as 
``$|\expr|$'' or ``the length of $\expr$'' depending on whether it appears in
a mathematical context or not.
To support intuitive prose notation, some \al conditions are specially rendered.
For example, while ``$\kwnot$'' is rendered as ``not'' and ``$\kwisvalid\;\expr$''
is rendered as ``$\expr$ is valid,''
``$\kwnot \; (\kwisvalid \; \expr)$'' is rendered as ``$\expr$ is not valid''
rather than ``not $\expr$ is valid.''

For example, the semantics of \inblue{\ensuremath{\mathsf{ref.is\_null}}}
in Fig.~\ref{fig:dsl} corresponds to the following in \al:
\[
\footnotesize
\begin{array}{lll}
\kwalg \; \mathit{REF.IS\_NULL} \kwrl \kwrr \; \kwcl &
  \kwassert \; \wasmc \\
& \kwpop \; \mathit{val}\\
& \kwif \; (\kwnot \; (\kwiscaseof \; \mathit{val} \; \mathit{REF.NULL\_val}))\\
& \quad \; \; \kwpush \; \ssf{CONST}(\ssf{I32}(0)) \\
& \quad \; \; \kwpush \; \ssf{CONST}(\ssf{I32}(1)) & \kwcr
\end{array}
\]

\subsection{DL2AL}\label{sec:dl2al} %3.5p
To bridge the gap between the two styles of semantics,
we present a mechanism for automatically deriving algorithmic ALs from declarative DSLs.
Several challenges arise in transforming declarative-style rewrite rules
into algorithmic-style prose pseudocode.
For example, a single Wasm instruction may have multiple rewrite rules
that describe different premises, but each instruction should only have one prose pseudocode.
In addition, the equals operator `$=$' in mathematical rules
can be ambiguous, as it can mean assignment or equality checking.
We show that the transformation is an NP-hard problem
and propose a practical solution.

\subsubsection{DL2DL Preprocessing} %3.5p
\paragraph{Unification} % 1p
\paragraph{Animation} % 2.5p
NP-hard: proof % 1.5p

solution: how % 1p
\subsubsection{DL2AL Transformation} % 1p
divide \& conquer

\subsection{Prose Backend}\label{sec:prose} %0.5p
AL is designed to provide a close and easy representation and manipulation of
the Wasm semantics in the official prose specification.
Thus, the English prose in reStructuredText markup can be generated directly from the definitions in AL.
\spectec can also support the interpretation of Wasm programs,
following the approach of the ESMeta framework.

\subsection{Interpreter Backend}\label{sec:interp} %1p
%
%  ESMeta parses the structured English prose algorithms of ECMAScript
% Specification document, and translates them into an internal representation, $IR_{ES}$.
%   $IR_{ES}$ has its own semantics, and thus can be executed with an interpreter implementation.
%   Executing the JavaScript semantics written in $IR_{ES}$ allows an indirect execution of JavaScript programs.
%   Utilizing the executable semantics, ESMeta derives a type checker for the specification, test
% suite synthesizers, and a static analyzer of JavaScript.
%
% Now, each ECMA-262 PR will execute the ESMeta type checker, and any new or changed tests in a Test262 PR will be executed using the ESMeta interpreter.
%
