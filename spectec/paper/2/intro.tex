\section{Introduction}\label{sec:intro}
\begin{figure}[t]
  \centering
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics[width=.7\textwidth]{../img/spec-prose.png}
\vspace*{-1em}
    \subcaption{Prose notation}
\vspace*{.5em}
  \end{subfigure}
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics[width=.7\textwidth]{../img/spec-formal.png}
    \subcaption{Formal notation}
  \end{subfigure}
\caption{Semantics of \ensuremath{t.\mathit{\inblue{binop}}} in the specification}
\label{fig:spec}
\end{figure}

A programming language is defined by its syntax and semantics.
Since syntax and semantics provide the foundation for all subsequent development and
analysis of the language, it is important to define them clearly and rigorously. 
Many programming languages, such as Java~\cite{javaspec} and Python~\cite{pythonspec},
therefore have language specifications that define their syntax and semantics.
For languages that are prone to implementation inconsistency issues,
such as C~\cite{cstandard} and JavaScript~\cite{ecmascript},
international committees define them according to their own standardization processes.
Some languages, like Standard ML~\cite{sml}, even have formal descriptions
that define them in mathematical notation.

WebAssembly (Wasm) is a low-level bytecode language and virtual machine~\cite{wasmspec}.
It was initially designed as an efficient compilation target and execution model on Web platforms
and has been adopted across a wide range of ecosystems,
including cloud and edge computing~\cite{lucet, cloudflare}, 
mobile and embedded systems~\cite{wasm-embedded}, IoT~\cite{wasm-iot}, and
blockchains~\cite{wasm-blockchain}.
Because different browsers implement Wasm within vendor-specific architectures
using multi-tier interpretation or just-in-time compilation,
Wasm faces the risk of implementation discrepancies.
The diversity of the various ecosystems exacerbates the situation.

To mitigate these risks, Wasm has been standardized by
the W3C Wasm Community Group~\cite{wasm-w3c}.
It requires four key artifacts for a feature to be standardized:
1) a \textit{formal specification} for the feature in declarative-style rewrite rules, written in LaTeX;
2) a \textit{prose pseudocode} presenting an algorithmic-style semantics, written in reStructuredText markup;
3) an extended \textit{reference interpreter} with the implementation of the feature, written in OCaml; and
4) a \textit{unit test suite} for the feature, written in the Wasm text format.
All of these artifacts must define the same behavior of a Wasm program.
Note that the specification provides \textit{both} declarative and algorithmic styles of semantic definitions.
For example, Fig.~\ref{fig:spec} shows the execution semantics of the binary operation instruction
$t.\mathit{\inblue{binop}}$ in the official Wasm specification.
Fig.~\ref{fig:spec}(a) presents the semantics in a prose notation broken down into five steps,
while Fig.~\ref{fig:spec}(b) specifies it in a formal notation using rewrite rules.

The two styles of semantic definitions cater to the dual needs of
language ``designers'' and ``implementers.''  Declarative rewrite
rules serve the needs of designers by focusing on clarity and
correctness of language semantics. They allow theorem provers like
Coq, Isabelle, Lean, and Agda to mechanize language semantics
and prove various properties, including type safety.
Algorithmic prose pseudocode, on the other hand, helps implementers
understand language behavior. A step-by-step description of the
language semantics can be a good guide to how to implement it.

Despite the onerous standardization process, the Wasm specification has been
written and maintained \textit{manually}, which creates challenges for specification writers.
Writing the prose is extremely laborious~\cite{Andreasicfp23}, and code reviews of
feature proposals written in LaTeX and reStructuredText are not user-friendly.
Manual processes are vulnerable to human error, potentially leading
to inconsistencies or inaccuracies in the specification.
As Wasm grows with new language features such as Garbage Collected Types, Threads,
and Exception Handling that will be supported by Wasm 3.0,
manually crafting all of the artifacts is not scalable.

These challenges call for the need to automate the process or \textit{mechanize} the language semantics.
For declarative-style rewrite rules, the literature shows general-purpose language frameworks such as
Ott~\cite{ott}, PLTRedex~\cite{pltredex}, Skeleton~\cite{skeleton}, Spoofax~\cite{spoofax},
and the K framework~\cite{k}. Among them, the K framework can generate various tools,
including interpreters, model checkers, and verifiers, from a language specification written in its language K.
It has specified the core semantics of real-world programming languages
such as C~\cite{kc}, Java~\cite{kjava}, Python~\cite{kpython}, and JavaScript~\cite{kjs}.
For algorithmic-style semantics, the ESMeta framework~\cite{esmeta}
can extract a mechanized specification from
an ECMAScript/JavaScript specification~\cite{ecmascript} and automatically
generate diverse tools~\cite{jiset,jest,jstar,jsaver}.
%
%  ESMeta parses the structured English prose algorithms of ECMAScript
% Specification document, and translates them into an internal representation, $IR_{ES}$.
%   $IR_{ES}$ has its own semantics, and thus can be executed with an interpreter implementation.
%   Executing the JavaScript semantics written in $IR_{ES}$ allows an indirect execution of JavaScript programs.
%   Utilizing the executable semantics, ESMeta derives a type checker for the specification, test
% suite synthesizers, and a static analyzer of JavaScript.
%
% Now, each ECMA-262 PR will execute the ESMeta type checker, and any new or changed tests in a Test262 PR will be executed using the ESMeta interpreter.
%
ESMeta has been officially integrated into the continuous integration (CI) systems of
the ECMAScript specification~\cite{ciecma262} and the Test262 conformance test suite~\cite{citest262}
since November 2022.
Because the existing language frameworks can mechanize only one style of semantics,
they are not applicable to Wasm, which should support both declarative and algorithmic styles of semantics.

\begin{figure}[t]
\footnotesize
\begin{verbatim}
                rule Step_pure/binop-val:
                    (CONST nt c_1) (CONST nt c_2) (BINOP nt binop) ~> (CONST nt c)
                    -- if $binop(binop, nt, c_1, c_2) = c

                rule Step_pure/binop-trap:
                    (CONST nt c_1) (CONST nt c_2) (BINOP nt binop) ~> TRAP
                    -- if $binop(binop, nt, c_1, c_2) = epsilon
\end{verbatim}
\caption{The binary operator semantics in \spectec's DSL}
\label{fig:dsl}
\end{figure}

In this paper, we propose \spectec, a framework for mechanizing Wasm semantics in both styles.
\spectec presents a \emph{Domain-Specific Language (DSL)} that
defines the Wasm syntax, type system, and execution semantics in a declarative style,
which serves as a single source of truth.
Figure~\ref{fig:dsl} illustrates the semantics of $t.\mathit{\inblue{binop}}$ in DSL,
which looks similar to the one in the official specification in Figure~\ref{fig:spec}(b).
Once the Wasm formal semantics is written in DSL,
a number of tools can be automatically generated as backends:
1) declarative backends, including LaTeX-based formal specifications and
mechanized definitions in various theorem provers, and
2) algorithmic backends, such as prose specifications in reStructuredText and Wasm interpreters.
By conducting meta-level error checking and automatically generating the required specification artifacts,
\spectec can alleviate the burden on language designers and implementers.

\spectec's DSL is designed to provide a close and easy representation and reasoning of
the Wasm semantics in declarative backends.
It can directly produce LaTeX-based formal specifications from the definitions in DSL,
and all definitions and variables in DSL are ``type-checked'' to detect ill-formed ones.
It can also generate mechanized definitions for theorem provers.
This saves language designers the trouble of manually specifying
language semantics in different theorem provers every time the specification is updated.

On the contrary, algorithmic backends are not directly produced from the definitions in DSL,
but from the definitions in the \emph{Algorithmic Language (AL)}.
AL is designed to provide a close and easy representation and manipulation of
the Wasm semantics in the official prose specification.
Thus, the English prose in reStructuredText markup can be generated directly from the definitions in AL.
\spectec can also support the interpretation of Wasm programs,
following the approach of the ESMeta framework.

To bridge the gap between the two styles of semantics,
we present a mechanism for automatically deriving algorithmic ALs from declarative DSLs.
Several challenges arise in transforming declarative-style rewrite rules
into algorithmic-style prose pseudocode.
For example, a single Wasm instruction may have multiple rewrite rules,
each expressing certain premises,
but each instruction should have only one prose pseudocode. 
In addition, the equals operator `$=$' in mathematical rules
can be ambiguous, as it can mean assignment or equality checking.
We show that the transformation is an NP-hard problem
and propose a practical solution.

\spectec is available as an open-source project~\cite{spectec}
and covers everything in Wasm 2.0 except SIMD instructions.
The automatically generated Wasm semantics in AL passes
100\% of the official test suite (except for SIMD) using an AL interpreter.
To further specify the semantics for Wasm 3.0, we only needed
to make minor adjustments in \spectec. During this process, we
reported a few errors in the Garbage Collected Types proposal and
received confirmation from the proposal champions.

This paper presents the following contributions:
\begin{itemize}
\item \textbf{\spectec is the first language semantics framework that
embraces both declarative and algorithmic styles of semantics.}
Unlike existing language frameworks that can mechanize only one style of semantics,
\spectec can support both styles of semantics.

\item \textbf{\spectec can automatically generate multiple backends from 
a single source of truth.}
It is designed to be easy to write, read, and reivew, enabling
meta-level error detection in the Wasm specification.
The automatically generated Wasm semantics passes
100\% of the official test suite (except for SIMD).


\item \textbf{\spectec is a forward-compatible toolchain that can
adapt to the evolving Wasm semantics.}
To evaluate the forward compatibility of \spectec, we applied it to five proposals
in Wasm 3.0 with minor adjustments, and found a few errors in the proposals.
\end{itemize}
