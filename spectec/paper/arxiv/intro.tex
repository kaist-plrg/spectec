%!TEX root = main.tex

\section{Introduction}
\label{sec:intro}

WebAssembly (Wasm) is a low-level bytecode language and virtual machine~\cite{wasm-pldi17}.  Initially introduced to
allow efficient compilation and execution of a larger variety of programming
languages on the Web platform, it has since been adopted across a broad range
of ecosystems, such as cloud and edge computing~\cite{lucet, cloudflare},
mobile and embedded systems~\cite{wasm-embedded}, IoT~\cite{wasm-iot}, and
blockchains~\cite{wasm-blockchain}.

Following its initial release, there has been growing demand for the
integration of new language features into Wasm. The version of Wasm initially
supported by browsers in 2017, referred to by its designers as a ``Minimum
Viable Product'' (MVP)~\cite{wasm-mvp}, served as a simple compilation target
for languages like C/C++ and Rust. However, the performance of
programs compiled with the MVP is suboptimal, and a few key features such as shared
memory concurrency and exception handling are not supported by the MVP. Other
languages involving runtime-managed memory such as Java
cannot be compiled without significant performance
or usability compromises, for example, because the Wasm MVP cannot easily
express the stack walking strategies used by the garbage collectors of
these languages' runtimes. Several proposals, including SIMD
Vector Instrutions~\cite{wasm-simd}, Exception Handling~\cite{wasm-exc}, Garbage Collected Types~\cite{wasm-gc}, and Threads~\cite{wasm-threads}
are being developed in Wasm to alleviate these problems.

For a feature to be standardised in Wasm, four key artefacts must be presented
to the W3C Wasm Community Group~\cite{wasm-w3c}:
\begin{itemize}
\item a \emph{formal specification} for the feature in the form of mathematical rules, written in LaTeX;
\item a \emph{prose pseudocode} description of the feature's behaviour, written in reStructuredText markup;
\item an implementation of the feature in the Wasm \emph{reference interpreter}, written in OCaml; and
\item a suite of \emph{unit tests} for the feature, written in (an enriched version of) the Wasm text format.
\end{itemize}
First, a formal specification significantly reduces the risk of under-defined edge cases. Indeed, if it is also accompanied by formal proofs of
appropriate correctness properties, as has been the case for the Wasm MVP,
certain risks such as type safety violations can be entirely precluded~\cite{Watt2018MechanisingAV, Watt2021Two}.
Second, the prose pseudocode description is designed to be more accessible to
non-experts, similar to other normative language specifications such as JavaScript's~\cite{ecmascript}.
Third, a reference interpreter can often be useful in situations where an optimised
implementation in a production engine is not yet available or is substantially
more complex.  Finally, the insistence on a comprehensive test suite for each
newly added feature further guarantees that various implementations of Wasm
exhibit consistent behavior.  This collective effort to include both
formal and prose specifications,
reference interpreters, and thorough test suites underscores the commitment to
precision, reliability, and compatibility within the Wasm standardization
process, and serve to reduce the risk of implementation divergence.

This meticulous process exists as a reaction to past experiences; historically Web languages have been particularly vulnerable to
issues of implementation discrepancy.  Leaving aside deliberate breaks from a Web standard by a browser vendor,
discrepancies may occur inadvertently simply due to the number of different browser implementations in existence, each one in itself consisting of several tiers of interpretation and just-in-time compilation.  Additionally, developers deploying code on the Web platform
have particuarly limited control over a Web site visitor's execution environment, amplifying the impact of
any discrepancies.  Portability is only feasible if implementations are meticulous in aligning their behaviours.

One significant challenge in Wasm's current standardisation
process~\cite{wasm-process} lies in the poor developer experience,
where the developer in question is an author of the specification artefacts described above.
The development of these
artefacts has on occasion lagged significantly behind other aspects of the standardisation process,
delaying the integration of a new proposal into the standard.
For example the highly anticipated Threads~\cite{wasm-threads} proposal has not yet been standardized in large part due to specification authoring delays.

The current Wasm specification~\cite{wasm-spec} is authored in reStructuredText,
a (somewhat cumbersome) markup language, from which both HTML and PDF documents
are generated by the Sphinx document processor \cite{sphinx}.
The formal pieces of the specification consist of embedded mathematics that must be
expressed in a (severely restricted) subset of LaTeX;
for HTML, it is rendered by MathJax \cite{mathjax}.
%
Wasm specification authors complain of the following significant difficulties in preparing and maintaining the specification text:\vspace{-0\baselineskip}
\begin{itemize}
\item lack of visual clarity when reading the raw source (complicating \emph{code reviews} and necessitating repeated lengthy builds);
\item absence of useful abstraction capabilities in Sphinx markup and in the available LaTeX subset
(due to the limitations of Sphinx and MathJax);
\item difficulty in interpreting LaTeX errors (because Sphinx generates one monolithic file before passing it to LaTeX, destroying line number information); and
\item no protection against misuse of definitions (e.g. wrong arguments, incorrect placement, incorrect symbol bindings).
\end{itemize}
\vspace{-0\baselineskip}

To address these challenges and improve the productivity of Wasm's standards
developers, we propose a unified domain-specific specification language and
corresponding toolchain, \emph{Wasm \dslname}.  \dslname will alleviate the
burden on developers by conducting meta-level error checking and automatically
generating the required specification artefacts.  Unlike existing
general-purpose specification languages such as Ott~\cite{ott},
PLTRedex~\cite{pltredex}, Skeleton~\cite{skeleton}, the K framework~\cite{k},
or Spoofax~\cite{spoofax}, our solution is unashamedly specialised to Wasm,  both to provide a development experience tailored to the expectations and needs of Wasm's standards
community, and to pursue more ambitious analyses and generated outputs which are only tractable with this more targetted scope. 
%
We ultimately aim for the Wasm standards community to specify all current and future Wasm features using \dslname and replace the manually authored
artefacts necessary for Wasm's standardization process with our generated artefacts, enhancing the  standardization process' efficiency and reliability.
%
Our in-development \dslname toolchain is available publicly~\cite{spectec}.
