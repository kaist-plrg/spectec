#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
import json
import argparse
import subprocess

from os import listdir
from os.path import isdir, isfile, join, basename, splitext, abspath, dirname
from pathlib import Path
from shutil import copyfile

from functools import reduce
from tempfile import TemporaryDirectory

from typing import Tuple, List

def parse_arg (arg: dict) -> List[str]:
    if arg['type'] == 'v128':
        v128 = reduce(lambda a, x: (a << (128 // len(arg['value']))) + int(x), reversed(arg['value']), 0)
        return ['v128', str(v128 & 0xFFFF_FFFF_FFFF_FFFF), str(v128 >> 64)]

    return [arg['type'], arg['value']]

def parse_expected (expected: dict) -> List[str]:
    if expected['type'] == 'v128':
        return ['v128', f'{len(expected["value"])}!' +\
                 '!'.join(sum(([expected['lane_type'], value] for value in expected['value']), []))]

    return [expected['type'], expected['value']]

def parse_expected_list (expected_list: List[str]) -> str:
    return ','.join(sum((parse_expected(expected) for expected in expected_list), []))

def encode_invoke (action: dict, ty: str, moduleName: str) -> str:
    args = ','.join(sum((parse_arg(arg) for arg in action['args']), []))
    return ','.join((ty, moduleName, action['field'], args))

def test_wast (path: str) -> Tuple[int, int]:
    if (basename(path) in ["imports.wast", "names.wast"]):
        """ Not supported """
        return 0, 0

    temp_dir = TemporaryDirectory(prefix="west-wasmedge-")
    temp_dir_path = temp_dir.name

    current_directory = abspath(dirname(__file__))

    dst_path = join(temp_dir_path, basename(path))
    copyfile(path, dst_path)

    subprocess.run (["wast2json", dst_path], cwd=temp_dir_path)

    filename = splitext(basename(path))[0]

    try:
        with open(join(temp_dir_path, filename + ".json")) as f:
            try:
                commands = json.load(f)['commands']
            except json.decoder.JSONDecodeError:
                return 0, 0
    except FileNotFoundError:
        return 0, 0

    total = 0

    alias = {}
    latestModuleName = None

    for command in commands:
        if (command['type'] == "module"):
            latestModuleName = command.get('name', str(command['line']))

        if (command['type'] == 'register'):
            alias[command['name'] if 'name' in command else latestModuleName] = command['as']

    text = ""

    for command in commands:
        if (command['type'] == "module"):
            na = command.get('name', str(command['line']))
            na = alias.get(na, na)

            latestModuleName = na

            text += ','.join(['mon', na, command['filename']])
            text += '\n'

        if (command['type'] == 'action'):
            action = command['action']

            if (action['type'] == 'invoke'):
                text += encode_invoke (action, 'act', latestModuleName)
                text += '\n'

        if (command['type'] == 'assert_return'):
            action = command['action']
            module = action.get('module', latestModuleName)
            module = alias.get(module, module)

            if (action['type'] == 'invoke'):
                text += encode_invoke (action, 'ari', module)
                text += f',{parse_expected_list (command["expected"])}\n'

            if (action['type'] == 'get'):
                text += ','.join(('art', module, action['field']))
                text += f',{parse_expected_list (command["expected"])}\n'

            total += 1

        if (command['type'] in 'assert_trap'):
            action = command['action']
            module = action.get('module', latestModuleName)
            module = alias.get(module, module)

            if (action['type'] == 'invoke'):
                text += encode_invoke (action, 'ati', module)
                text += '\n'

                total += 1

        if (command['type'] == 'assert_invalid'):
            text += ','.join(('aiv', command['filename']))
            text += '\n'

            total += 1

        if (command['type'] == 'assert_malformed'):
            if (splitext(command['filename'])[-1] == '.wat'):
                continue

            text += ','.join(('ama', command['filename']))
            text += '\n'

            total += 1

        if (command['type'] in ['assert_unlinkable', 'assert_uninstantiable']):
            text += ','.join(('aun', command['filename']))
            text += '\n'

            total += 1

    with open(join(temp_dir_path, f"{filename}.txt"), "w", encoding="utf-8") as f:
        f.write(text)

    print(f'==== {basename(path)} ====')

    ps = subprocess.run ([join(current_directory, "tester"), f"{filename}.txt"], cwd=temp_dir_path,
                         stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    print(ps.stderr.decode("utf-8"), end='', file=sys.stderr)

    out = ps.stdout.decode("utf-8")

    correct = 0

    try:
        correct = int(out.split()[-1])
    except:
        pass

    temp_dir.cleanup()

    try:
        print(f'- {correct}/{total} ({correct/total*100:.2f}%)\n')
    except ZeroDivisionError:
        print(f'- {correct}/{total} (nan%)\n')

    return correct, total

def get_wast_files (path: str) -> List[str]:
    if isfile(path) and path.endswith(".wast"):
        return [path]

    if isdir(path):
        return sum((get_wast_files(join(path, file)) for file in listdir(path)), [])

    return []

def pad_zeros (path: str) -> str:
    pathObj = Path(path)

    try:
        newFileName = int(pathObj.stem)
        return f'{str(pathObj.parent)}/{newFileName:09}.wast'
    except ValueError:
        return path

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description="Test WasmEdge with .wast files"
    )
    parser.add_argument(
        "path",
        type=str,
        help="Path to .wast file or directory containing .wast files",
    )
    args = parser.parse_args()

    wast_files = get_wast_files(args.path)

    if not wast_files:
        print (f'No .wast files found in {args.path}')
        print ('exiting...')
        exit (1)

    correct = 0
    total = 0

    wast_files.sort(key=pad_zeros)

    incorrect_files = []

    for wast_file in wast_files:
        c, t = test_wast (wast_file)

        if c != t:
            incorrect_files.append(wast_file)

        correct += c
        total += t

    print(incorrect_files)

    try:
        print(f'Total [{correct}/{total}] ({correct/total*100:.2f}%)')
    except ZeroDivisionError:
        print(f'Total [{correct}/{total}] (nan%)')
