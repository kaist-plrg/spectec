;;
;; Configurations
;;

relation Step: config ~> config                 hint(show "E")
relation Step_pure: admininstr* ~> admininstr*  hint(show "E")
relation Step_read: config ~> admininstr*       hint(show "E")
relation Steps: config ~>* config               hint(show "E")

rule Step/pure:
  z; instr*  ~>  z; instr'*
  -- Step_pure: instr* ~> instr'*

rule Step/read:
  z; instr*  ~>  z; instr'*
  -- Step_read: z; instr* ~> instr'*

rule Steps/refl:
  z; admininstr* ~>* z; admininstr*

rule Steps/trans:
  z; admininstr*  ~>*  z''; admininstr''*
  -- Step: z; admininstr*  ~>  z'; admininstr'*
  -- Steps: z'; admininstr'  ~>*  z''; admininstr''*


;; Expressions

relation Eval_expr: state; expr ~>* state; val*  hint(show "E-expr")

rule Eval_expr:
  z; instr*  ~>*  z'; val*
  -- Steps: z; instr*  ~>*  z'; val*


;;
;; Instructions
;;

;; Numeric instructions

rule Step_pure/unop-val:
  (CONST nt c_1) (UNOP nt unop)  ~>  (CONST nt c)
  -- if $unop(unop, nt, c_1) = c  ;; TODO

rule Step_pure/unop-trap:
  (CONST nt c_1) (UNOP nt unop)  ~>  TRAP
  -- if $unop(unop, nt, c_1) = eps  ;; TODO


rule Step_pure/binop-val:
  (CONST nt c_1) (CONST nt c_2) (BINOP nt binop)  ~>  (CONST nt c)
  -- if $binop(binop, nt, c_1, c_2) = c  ;; TODO

rule Step_pure/binop-trap:
  (CONST nt c_1) (CONST nt c_2) (BINOP nt binop)  ~>  TRAP
  -- if $binop(binop, nt, c_1, c_2) = eps  ;; TODO


rule Step_pure/testop:
  (CONST nt c_1) (TESTOP nt testop)  ~>  (CONST I32 c)
  -- if c = $testop(testop, nt, c_1)

rule Step_pure/relop:
  (CONST nt c_1) (CONST nt c_2) (RELOP nt relop)  ~>  (CONST I32 c)
  -- if c = $relop(relop, nt, c_1, c_2)


rule Step_pure/extend:
  (CONST nt c) (EXTEND nt n)  ~>  (CONST nt $ext(n, $size(nt), S, $wrap($size(nt), n, c)))


rule Step_pure/cvtop-val:
  (CONST nt_1 c_1) (CVTOP nt_2 cvtop nt_1 sx?)  ~>  (CONST nt_2 c)
  -- if $cvtop(cvtop, nt_1, nt_2, sx?, c_1) = c  ;; TODO

rule Step_pure/cvtop-trap:
  (CONST nt_1 c_1) (CVTOP nt_2 cvtop nt_1 sx?)  ~>  TRAP
  -- if $cvtop(cvtop, nt_1, nt_2, sx?, c_1) = eps  ;; TODO


;; Vector instructions

rule Step_pure/vvunop:
  (VVCONST V128 cv_1) (VVUNOP V128 vvunop)  ~>  (VVCONST V128 cv)
  -- if $vvunop(vvunop, V128, cv_1) = cv ;; TODO


rule Step_pure/vvbinop:
  (VVCONST V128 cv_1) (VVCONST V128 cv_2) (VVBINOP V128 vvbinop)  ~>  (VVCONST V128 cv)
  -- if $vvbinop(vvbinop, V128, cv_1, cv_2) = cv ;; TODO


rule Step_pure/vvternop:
  (VVCONST V128 cv_1) (VVCONST V128 cv_2) (VVCONST V128 cv_3) (VVTERNOP V128 vvternop)  ~>  (VVCONST V128 cv)
  -- if $vvternop(vvternop, V128, cv_1, cv_2, cv_3) = cv ;; TODO


rule Step_pure/vvtestop:
  (VVCONST V128 cv_1) (VVTESTOP V128 (_VV ANY_TRUE)) ~> (CONST I32 i)
  -- if i = $ine(128, cv_1, $vzero)


rule Step_pure/vswizzle:
  (VVCONST V128 cv_1) (VVCONST V128 cv_2) (VSWIZZLE sh) ~> (VVCONST V128 cv')
  -- if sh = lnt X lns
  -- if i* = $lanes(sh, cv_2)
  -- if c* = $lanes(sh, cv_1) 0^(256 - lns)
  -- if $lanes(sh, cv') = c*[$(i*[k])]^(k<lns)


rule Step_pure/vshuffle:
  (VVCONST V128 cv_1) (VVCONST V128 cv_2) (VSHUFFLE sh laneidx*) ~> (VVCONST V128 cv)
  -- if sh = lnt X lns
  -- if i* = $lanes(sh, cv_1) $lanes(sh, cv_2)
  -- if $lanes(sh, cv) = i*[$(laneidx*[k])]^(k<lns)


rule Step_pure/vsplat:
  (CONST nt c_1) (VSPLAT sh) ~> (VVCONST V128 cv)
  -- if nt = $unpacked(sh)
  -- if $lanes(sh, cv) = c_1^$dim(sh)


rule Step_pure/vextract_lane-num:
  (VVCONST V128 cv_1) (VEXTRACT_LANE sh laneidx) ~> (CONST nt c_2)
  -- if nt = $unpacked(sh)
  -- if sh = lnt X lns
  -- if c_2 = $ext($lanesize(lnt), $size(nt), U, $lanes(sh, cv_1)[laneidx])

rule Step_pure/vextract_lane-pack:
  (VVCONST V128 cv_1) (VEXTRACT_LANE sh sx laneidx) ~> (CONST nt c_2)
  -- if nt = $unpacked(sh)
  -- if sh = lnt X lns
  -- if c_2 = $ext($lanesize(lnt), $size(nt), sx, $lanes(sh, cv_1)[laneidx])


rule Step_pure/vreplace_lane:
  (VVCONST V128 cv_1) (CONST nt c_2) (VREPLACE_LANE sh laneidx) ~> (VVCONST V128 cv)
  -- if i* = $lanes(sh, cv_1)
  -- if $lanes(sh, cv) = (i*)[[laneidx] = c_2]


rule Step_pure/vunop:
  (VVCONST V128 cv_1) (VUNOP sh vunop)  ~>  (VVCONST V128 cv)
  -- if cv = $vunop(vunop, sh, cv_1)


rule Step_pure/vbinop-val:
  (VVCONST V128 cv_1) (VVCONST V128 cv_2) (VBINOP sh vbinop)  ~>  (VVCONST V128 cv)
  -- if $vbinop(vbinop, sh, cv_1, cv_2) = cv

rule Step_pure/vbinop-trap:
  (VVCONST V128 cv_1) (VVCONST V128 cv_2) (VBINOP sh vbinop)  ~>  TRAP
  -- if $vbinop(vbinop, sh, cv_1, cv_2) = eps


rule Step_pure/vrelop:
  (VVCONST V128 cv_1) (VVCONST V128 cv_2) (VRELOP sh vrelop)  ~>  (VVCONST V128 cv)
  -- if i* = $lanes(sh, cv_1)
  -- if j* = $lanes(sh, cv_2)
  -- if sh = lnt X lns
  -- if $lanes(sh, cv) = $ext(1, $lanesize(lnt), S, $vrelop(vrelop, sh, i, j))*


rule Step_pure/vishiftop:
  (VVCONST V128 cv_1) (CONST I32 n) (VISHIFTOP sh vishiftop) ~> (VVCONST V128 cv)
  -- if sh = lnt X lns
  -- if i* = $lanes(sh, cv_1)
  -- if $lanes(sh, cv) = $vishiftop(vishiftop, lnt, i, n)*


rule Step_pure/vall_true-true:
  (VVCONST V128 cv) (VALL_TRUE sh) ~> (CONST I32 1)
  -- if i_1* = $lanes(sh, cv)
  -- (if $(i_1 =/= 0))*

rule Step_pure/vall_true-false:
  (VVCONST V128 cv) (VALL_TRUE sh) ~> (CONST I32 0)
  -- otherwise


rule Step_pure/vbitmask:
  (VVCONST V128 cv) (VBITMASK sh) ~> (CONST I32 i)
  -- if sh = lnt X lns
  -- if i_1^lns = $lanes(sh, cv)
  -- if $ibits(32, i) = $ilt(S, $lanesize(lnt), i_1, 0)^lns


rule Step_pure/vnarrow:
  (VVCONST V128 cv_1) (VVCONST V128 cv_2) (VNARROW sh_2 sh_1 sx) ~> (VVCONST V128 cv)
  -- if sh_1 = lnt_1 X lns_1
  -- if sh_2 = lnt_2 X lns_2
  -- if i_1^lns_1 = $lanes(sh_1, cv_1)
  -- if i_2^lns_1 = $lanes(sh_1, cv_2)
  -- if n_1^lns_1 = $narrow($lanesize(lnt_1), $lanesize(lnt_2), sx, i_1)^lns_1
  -- if n_2^lns_1 = $narrow($lanesize(lnt_1), $lanesize(lnt_2), sx, i_2)^lns_1
  -- if $lanes(sh_2, cv) = n_1^lns_1 n_2^lns_1


rule Step_pure/vcvtop-normal:
  (VVCONST V128 cv_1) (VCVTOP sh_2 vcvtop eps sh_1 sx eps) ~> (VVCONST V128 cv)
  -- if sh_1 = lnt_1 X lns_1
  -- if sh_2 = lnt_2 X lns_2
  -- if i* = $lanes(sh_1, cv_1)
  -- if $lanes(sh_2, cv) = $vcvtop(vcvtop, $lanesize(lnt_1), $lanesize(lnt_2), sx, i)*


rule Step_pure/vcvtop-half:
  (VVCONST V128 cv_1) (VCVTOP sh_2 vcvtop hf sh_1 sx? eps) ~> (VVCONST V128 cv)
  -- if sh_1 = lnt_1 X lns_1
  -- if sh_2 = lnt_2 X lns_2
  -- if i* = $lanes(sh_1, cv_1)[$halfop(hf, 0, lns_2) : lns_2]
  -- if $lanes(sh_2, cv) = $vcvtop(vcvtop, $lanesize(lnt_1), $lanesize(lnt_2), sx?, i)*


rule Step_pure/vcvtop-zero:
  (VVCONST V128 cv_1) (VCVTOP sh_2 vcvtop eps sh_1 sx? ZERO) ~> (VVCONST V128 cv)
  -- if sh_1 = lnt_1 X lns_1
  -- if sh_2 = lnt_2 X lns_2
  -- if i* = $lanes(sh_1, cv_1)
  -- if $lanes(sh_2, cv) = $vcvtop(vcvtop, $lanesize(lnt_1), $lanesize(lnt_2), sx?, i)* 0^lns_1


rule Step_pure/vdot:
  (VVCONST V128 cv_1) (VVCONST V128 cv_2) (VDOT sh_1 sh_2 S) ~> (VVCONST V128 cv)
  -- if sh_1 = lnt_1 X lns_1
  -- if sh_2 = lnt_2 X lns_2
  -- if i_1 = $lanesize(lnt_1)
  -- if i_2 = $lanesize(lnt_2)
  -- if k_1^k' = $lanes(sh_2, cv_1)
  -- if k_2^k' = $lanes(sh_2, cv_2)
  -- if $concat_bytes((j_1 j_2)*) = $imul(i_1, $ext(i_2, i_1, S, k_1), $ext(i_2, i_1, S, k_2))^k'
  -- if j'* = $iadd(i_1, j_1, j_2)*
  -- if $lanes(sh_1, cv) = j'*


rule Step_pure/vextmul:
  (VVCONST V128 cv_1) (VVCONST V128 cv_2) (VEXTMUL sh_2 hf sh_1 sx) ~> (VVCONST V128 cv)
  -- if sh_1 = lnt_1 X lns_1
  -- if sh_2 = lnt_2 X lns_2
  -- if i^k = $lanes(sh_1, cv_1)[$halfop(hf, 0, lns_2) : lns_2]
  -- if j^k = $lanes(sh_1, cv_2)[$halfop(hf, 0, lns_2) : lns_2]
  -- if $lanes(sh_2, cv) = $imul($lanesize(lnt_2), $ext($lanesize(lnt_1), $lanesize(lnt_2), sx, i), $ext($lanesize(lnt_1), $lanesize(lnt_2), sx, j))^k


rule Step_pure/vextadd_pairwise:
  (VVCONST V128 cv_1) (VEXTADD_PAIRWISE sh_2 sh_1 sx) ~> (VVCONST V128 cv)
  -- if sh_1 = lnt_1 X lns_1
  -- if sh_2 = lnt_2 X lns_2
  -- if i^k = $lanes(sh_1, cv_1)
  -- if $concat_bytes((i_1 i_2)*) = $ext($lanesize(lnt_1), $lanesize(lnt_2), sx, i)^k
  -- if j* = $iadd($lanesize(lnt_2), i_1, i_2)*
  -- if $lanes(sh_2, cv) = j*



;; Local instructions

rule Step_read/local.get:
  z; (LOCAL.GET x)  ~>  $local(z, x)

rule Step/local.set:
  z; val (LOCAL.SET x)  ~>  $with_local(z, x, val); eps

rule Step_pure/local.tee:
  val (LOCAL.TEE x)  ~>  val val (LOCAL.SET x)


;; Call instructions

rule Step_read/call_addr:
  z; val^k (CALL_ADDR a)  ~>  (FRAME_ n `{f} (LABEL_ n `{eps} instr*))
  -- if $funcinst(z)[a] = {TYPE (t_1^k -> t_2^n), MODULE mm, CODE func}
  -- if func = FUNC x (LOCAL t)* instr*
  -- if f = {LOCAL val^k ($default(t))*, MODULE mm}

rule Step_pure/frame-vals:
  (FRAME_ n `{f} val^n)  ~>  val^n

rule Step_pure/label-vals:
  (LABEL_ n `{instr*} val*)  ~>  val*
