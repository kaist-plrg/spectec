;;
;; Contexts
;;

syntax context hint(desc "context") =
  { TYPE functype*, FUNC functype*, LOCAL valtype*, LABEL resulttype*, RETURN resulttype? }

var C : context



;;
;; Types
;;

relation Functype_ok: |- functype : OK      hint(show "K-func")
relation Externtype_ok: |- externtype : OK  hint(show "K-extern")


rule Functype_ok:
  |- ft : OK


rule Externtype_ok/func:
  |- FUNC functype : OK
  -- Functype_ok: |- functype : OK


;;
;; Subtyping
;;

;; Value types

relation Valtype_sub: |- valtype <: valtype       hint(show "S")
relation Resulttype_sub: |- valtype* <: valtype*  hint(show "S-result")

rule Valtype_sub/refl:
  |- t <: t

rule Resulttype_sub:
  |- t_1* <: t_2*
  -- (Valtype_sub: |- t_1 <: t_2)*


;; External types

relation Functype_sub: |- functype <: functype       hint(show "S-func")
relation Externtype_sub: |- externtype <: externtype hint(show "S-extern")


rule Functype_sub:
  |- ft <: ft


rule Externtype_sub/func:
  |- FUNC ft_1 <: FUNC ft_2
  -- Functype_sub: |- ft_1 <: ft_2



;;
;; Instructions
;;

relation Instr_ok: context |- instr : functype   hint(show "T")
relation Instrs_ok: context |- instr* : functype hint(show "T*")
relation Expr_ok: context |- expr : resulttype   hint(show "T-expr")


;; Expressions

rule Expr_ok:
  C |- instr* : t*
  -- Instrs_ok: C |- instr* : eps -> t*


;; Instruction sequences

rule Instrs_ok/empty:
  C |- eps : eps -> eps

rule Instrs_ok/seq:
  C |- instr_1 instr_2* : t_1* -> t_3*
  -- Instr_ok: C |- instr_1 : t_1* -> t_2*
  -- Instrs_ok: C |- instr_2 : t_2* -> t_3*

rule Instrs_ok/sub:
  C |- instr* : t'_1* -> t'_2*
  -- Instrs_ok: C |- instr* : t_1* -> t_2*

  -- Resulttype_sub: |- t'_1* <: t_1*
  -- Resulttype_sub: |- t_2* <: t'_2*

rule Instrs_ok/frame:
  C |- instr* : t* t_1* -> t* t_2*
  -- Instrs_ok: C |- instr* : t_1* -> t_2*




;; Numeric instructions

rule Instr_ok/const:
  C |- CONST nt c_nt : eps -> nt

rule Instr_ok/select-expl:
  C |- SELECT t : t t I32 -> t

rule Instr_ok/select-impl:
  C |- SELECT : t t I32 -> t
  -- Valtype_sub: |- t <: t'
  -- if t' = numtype \/ t' = vectype



;; Vector instructions

rule Instr_ok/vvconst:
  C |- VVCONST V128 c_vt : eps -> V128

rule Instr_ok/vvunop:
  C |- VVUNOP vt vvunop : V128 -> V128

rule Instr_ok/vvbinop:
  C |- VVBINOP vt vvbinop : V128 V128 -> V128

rule Instr_ok/vvternop:
  C |- VVTERNOP vt vvternop : V128 V128 V128 -> V128

rule Instr_ok/vvtestop:
  C |- VVTESTOP vt vvtestop : V128 -> I32

rule Instr_ok/vswizzle:
  C |- VSWIZZLE sh : V128 V128 -> V128

rule Instr_ok/vshuffle:
  C |- VSHUFFLE sh laneidx* : V128 V128 -> V128
  -- (if $(laneidx<$dim(sh) * 2))*

rule Instr_ok/vsplat:
  C |- VSPLAT sh : $unpacked(sh) -> V128

rule Instr_ok/vextract_lane:
  C |- VEXTRACT_LANE sh sx? laneidx : V128 -> $unpacked(sh)
  -- if laneidx < $dim(sh)

rule Instr_ok/vreplace_lane:
  C |- VREPLACE_LANE sh laneidx : V128 $unpacked(sh) -> V128
  -- if laneidx < $dim(sh)

rule Instr_ok/vunop:
  C |- VUNOP sh vunop : V128 -> V128

rule Instr_ok/vbinop:
  C |- VBINOP sh vbinop : V128 V128 -> V128

rule Instr_ok/vrelop:
  C |- VRELOP sh vrelop : V128 V128 -> V128

rule Instr_ok/vishiftop:
  C |- VISHIFTOP sh vishiftop : V128 I32 -> V128

rule Instr_ok/vall_true:
  C |- VALL_TRUE sh : V128 -> I32

rule Instr_ok/vcvtop:
  C |- VCVTOP sh vcvtop hf? sh sx? zero : V128 -> V128

rule Instr_ok/vnarrow:
  C |- VNARROW sh sh sx : V128 V128 -> V128

rule Instr_ok/vbitmask:
  C |- VBITMASK sh : V128 -> I32

rule Instr_ok/vdot:
  C |- VDOT sh sh sx : V128 V128 -> V128

rule Instr_ok/vextmul:
  C |- VEXTMUL sh half sh sx : V128 V128 -> V128

rule Instr_ok/vextadd_pairwise:
  C |- VEXTADD_PAIRWISE sh sh sx : V128 -> V128


;;
;; Constant Expressions
;;

relation Instr_const: context |- instr CONST             hint(show "C-instr")
relation Expr_const: context |- expr CONST               hint(show "C-expr")
relation Expr_ok_const: context |- expr : valtype CONST  hint(show "TC-expr")

rule Instr_const/const:
  C |- (CONST nt c) CONST

rule Instr_const/vvconst:
  C |- (VVCONST vt c_vt) CONST


rule Expr_const: C |- instr* CONST
  -- (Instr_const: C |- instr CONST)*


rule Expr_ok_const:
  C |- expr : t CONST
  -- Expr_ok: C |- expr : t
  -- Expr_const: C |- expr CONST


;;
;; Modules
;;

relation Type_ok: |- type : functype                 hint(show "T-type")
relation Func_ok: context |- func : functype         hint(show "T-func")


;; Module definitions

rule Type_ok:
  |- TYPE ft : ft
  -- Functype_ok: |- ft : OK

rule Func_ok:
  C |- FUNC x (LOCAL t)* expr : t_1* -> t_2*
  -- if C.TYPE[x] = t_1* -> t_2*
  -- Expr_ok: C, LOCAL t_1* t*, LABEL (t_2*), RETURN (t_2*) |- expr : t_2*


;; Module im/exports

relation Export_ok: context |- export : externtype        hint(show "T-export")
relation Externidx_ok: context |- externidx : externtype  hint(show "T-externidx")

rule Export_ok:
  C |- EXPORT name externidx : xt
  -- Externidx_ok: C |- externidx : xt


rule Externidx_ok/func:
  C |- FUNC x : FUNC ft
  -- if C.FUNC[x] = ft


;; Modules proper

relation Module_ok: |- module : OK      hint(show "T-module")

rule Module_ok:
  |- MODULE type* eps func* eps eps eps eps eps eps export* : OK
  ;; TODO: incremental contexts for globals
  -- if C = {TYPE ft'*, FUNC ft*}

  -- (Type_ok: |- type : ft')*
  -- (Func_ok: C |- func : ft)*

  ;; -- TODO: disjoint export names
