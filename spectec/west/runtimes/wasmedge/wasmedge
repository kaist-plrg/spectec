#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import json
import argparse
import subprocess

from os import listdir
from os.path import isdir, isfile, join, basename, splitext, abspath, dirname
from shutil import copyfile

from functools import reduce
from tempfile import TemporaryDirectory

def parse_value (value: dict) -> list:
    if value['type'] == 'v128':
        print(str(reduce(lambda a, x: (a << (128 // len(value['value']))) + int(x), value['value'], 0)))
        return ['v128', str(reduce(lambda a, x: (a << (128 // len(value['value']))) + int(x), value['value'], 0))]

    return [value['type'], value['value']]

def parse_values (values: list) -> str:
    return ','.join(sum((parse_value(value) for value in values), []))

def encode_invoke (action: dict, ty: str, moduleName: str) -> str:
    return ','.join((ty, moduleName, action['field'], parse_values (action['args'])))

def test_wast (path: str) -> tuple[int, int]:
    if (basename(path) in ["imports.wast", "names.wast"]):
        """ Not supported """
        return 0, 0

    temp_dir = TemporaryDirectory(prefix="west-wasmedge-")
    temp_dir_path = temp_dir.name

    dst_path = join(temp_dir_path, basename(path))
    copyfile(path, dst_path)

    subprocess.run (["wast2json", dst_path], cwd=temp_dir_path)

    filename = splitext(basename(path))[0]

    with open(join(temp_dir_path, filename + ".json")) as f:
        commands = json.load(f)['commands']

    total = 0

    alias = {}
    latestModuleName = None

    for command in commands:
        if (command['type'] == "module"):
            latestModuleName = command.get('name', str(command['line']))

        if (command['type'] == 'register'):
            alias[command['name'] if 'name' in command else latestModuleName] = command['as']

    text = ""

    for command in commands:
        if (command['type'] == "module"):
            na = command.get('name', str(command['line']))
            na = alias.get(na, na)

            latestModuleName = na

            text += ','.join(['mon', na, command['filename']])
            text += '\n'

        if (command['type'] == 'action'):
            action = command['action']

            if (action['type'] == 'invoke'):
                text += encode_invoke (action, 'act', latestModuleName)
                text += '\n'

        if (command['type'] == 'assert_return'):
            action = command['action']

            if (action['type'] == 'invoke'):
                text += encode_invoke (action, 'ari', action.get('module', latestModuleName))
                text += f',{parse_values (command["expected"])}\n'

            if (action['type'] == 'get'):
                text += ','.join(('art', action.get('module', latestModuleName), action['field']))
                text += f',{parse_values (command["expected"])}\n'

            total += 1

        if (command['type'] in 'assert_trap'):
            action = command['action']

            if (action['type'] == 'invoke'):
                text += encode_invoke (action, 'ati', latestModuleName)
                text += f',{command["text"]}\n'

                total += 1

        if (command['type'] == 'assert_invalid'):
            text += ','.join(('aiv', command['filename'], command['text']))
            text += '\n'

            total += 1

        if (command['type'] in ['assert_unlinkable', 'assert_uninstantiable']):
            text += ','.join(('aun', command['filename'], command['text']))
            text += '\n'

            total += 1

    with open(join(temp_dir_path, f"{filename}.txt"), "w", encoding="utf-8") as f:
        f.write(text)

    print(f'==== {basename(path)} ====')

    ps = subprocess.run ([join(abspath(dirname(__file__)), "tester"), f"{filename}.txt"], cwd=temp_dir_path,
                         stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    print(ps.stderr.decode("utf-8"), end='', file=sys.stderr)

    out = ps.stdout.decode("utf-8")

    correct = 0

    try:
        correct = int(out.split()[-1])
    except:
        pass

    temp_dir.cleanup()

    try:
        print(f'- {correct}/{total} ({correct/total*100:.2f}%)\n')
    except ZeroDivisionError:
        print(f'- {correct}/{total} (nan%)\n')

    return correct, total

def get_wast_files (path: str) -> list[str]:
    if isfile(path) and path.endswith(".wast"):
        return [path]

    if isdir(path):
        return sum((get_wast_files(join(path, file)) for file in listdir(path)), [])

    return []

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description="Test WasmEdge with .wast files"
    )
    parser.add_argument(
        "path",
        type=str,
        help="Path to .wast file or directory containing .wast files",
    )
    args = parser.parse_args()

    wast_files = get_wast_files(args.path)

    if not wast_files:
        print (f'No .wast files found in {args.path}')
        print ('exiting...')
        exit (1)

    correct = 0
    total = 0

    wast_files.sort()

    for wast_file in wast_files:
        c, t = test_wast (wast_file)

        correct += c
        total += t

    try:
        print(f'Total [{correct}/{total}] ({correct/total*100:.2f}%)')
    except ZeroDivisionError:
        print(f'Total [{correct}/{total}] (nan%)')

